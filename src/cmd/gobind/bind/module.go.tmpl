/*
Module generated by gobind CLI tool, do not edit manually.
*/
package {{.Package}}

/*
#cgo CFLAGS: -I/usr/local/include
#cgo LDFLAGS: -Wl,-rpath,/usr/local/lib -Wl,-rpath,"{{.LibraryDir}}" -L/usr/local/lib -L"{{.LibraryDir}}" -ldl -lcgobind -lgobind -l{{.Package}}

// C wrapper includes:
#include "cgobind/cgobind_helper.h"

// Init function definition:
GobindModule* gobind_init_{{.Package}}();
*/
import "C"

import (
	"unsafe"

	util "github.com/soerlemans/gobind/src/lib/go_util"
)

type CIntType interface {
	C.int8_t |
		C.int16_t |
		C.int32_t |
		C.int64_t |
		C.uint8_t |
		C.uint16_t |
		C.uint32_t |
		C.uint64_t
}

var exportedFunctions = make(map[string]C.GobindFunction)

func CPtr2Array[ArrayType any, CInt CIntType](t_ptr *ArrayType, t_size CInt) []ArrayType {
	size := int(t_size)
	util.Logf("Array size: %d", size)
	array := unsafe.Slice(t_ptr, size)

	return array
}

// Return the names of registered modules.
func InitModule() *C.GobindModule {
	var module *C.GobindModule

	modulePtr := C.gobind_init_{{.Package}}()
	module = (*C.GobindModule)(modulePtr)

	util.Logf("Module name: %s", C.GoString(module.m_name))

	return module
}

func init() {
		// Obtain the module.
		module:= InitModule()

		fn_table := module.m_fn_table
		functions := CPtr2Array(fn_table.m_functions, fn_table.m_size)
		for index := 0; index < int(fn_table.m_size); index++ {
			function := functions[index]
			functionName := C.GoString(function.m_name)

			exportedFunctions[functionName] = function
		}
}

{{range .Functions}}
func {{.Name}}({{.Params}}) {{.ReturnType}} {
	  // Call function inside of exportedFunctions map.
	  fnStruct := exportedFunctions["{{.Name}}"]
	  fnPtr := unsafe.Pointer(fnStruct.m_fn)

	  C.call_void_func(fnPtr)

    return nil
}
{{end}}
